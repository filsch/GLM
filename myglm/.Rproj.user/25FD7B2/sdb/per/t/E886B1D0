{
    "contents" : "myglm = function(formula, data = list(), ...){\n  # Extract model matrix & responses\n  mf = model.frame(formula = formula, data = data)\n  X  = model.matrix(attr(mf, \"terms\"), data = mf)\n  y  = model.response(mf)\n  terms = attr(mf, \"terms\")\n\n  if (attr(terms,\"intercept\") == 1){\n    rss_null <- t(y-mean(y))%*%(y-mean(y))\n    p = ncol(X) - 1\n  } else{\n    rss_null <- t(y)%*%y\n    p = ncol(X)\n  }\n\n  beta_hat = solve(t(X)%*%X)%*%t(X)%*%y;      residuals = y - X%*%beta_hat;       rss_beta = t(y - X%*%beta_hat)%*%(y - X%*%beta_hat)\n  n = nrow(X);                                sigma2 = as.numeric(rss_beta/n);\n  beta_hat_cov = solve((t(X)%*%X)) * sigma2;  fitted = as.vector(X %*% beta_hat)\n  R_squared = 1 - rss_beta/rss_null;          adj_R_squared = R_squared - (1 - R_squared) * (p)/(n - p)\n\n  est = list(terms = terms, model = mf, coefficients = beta_hat, beta_cov = beta_hat_cov,\n             residuals = residuals, n=n, p = p, sigma2=sigma2,\n             rss_beta = rss_beta, rss_null = rss_null, fitted = fitted, y = y,\n             R_squared = R_squared, adj_R_squared = adj_R_squared, x = X)\n  # Store call and formula used\n  est$call = match.call()\n  est$formula = formula\n  # Set class name. This is very important!\n  class(est) = 'myglm'\n  # Return the object with all results\n  return(est)\n}\n\nprint.myglm = function(x, ...){\n  cat('Call: \\n')\n  print(x$call)\n  cat('\\nCoefficients: \\n')\n  print(x$coefficients[,])\n}\n\nsummary.myglm = function(object, ...){\n  coeff = object$coefficients; resid = object$residuals; p = object$p; n = object$n\n  std_error = z_value = z_score = numeric(length(coeff))\n  for (i in 1:length(coeff)){\n    z_value[i]   = coeff[i] / sqrt(object$beta_cov[i,i])\n    std_error[i] = sqrt(object$beta_cov[i,i])\n  }\n  z_score   = 1 - pnorm(abs(z_value), mean = 0, sd = 1)\n  chi_stat = ((object$rss_null - object$rss_beta)/p) / (object$rss_beta/(n - p))\n  chi_p_value = 1 - pchisq(chi_stat, p)\n  chi_p_value[chi_p_value < 2e-16] <- '< 2e-16';   z_score[z_score < 2e-16] <- '< 2e-16'\n\n\n  options(scipen=0)\n  cat(\"Call: \\n\")\n  print(object$call)\n  cat('\\n Residuals: \\n')\n  frame = data.frame(min(resid), quantile(resid, 0.25), median(resid),\n                     quantile(resid, 0.75), max(resid), row.names = '')\n  colnames(frame) <- c('Min','1stQ','Median','3rdQ','Max')\n  print(frame)\n  cat(\"\\n Coefficients: \\n\")\n  frame = data.frame(round(coeff,3), round(std_error,3), round(z_value,3), z_score)\n  colnames(frame) <- c('Estimate','Std. Error','Z-value','Z-score')\n  print(frame)\n  cat('--- \\n')\n  cat(\"Residual standard error: \", sqrt(object$sigma2), \" on \", n-p, \" degrees of freedom \\n\")\n  cat(\"Multiple R-squared: \", round(object$R_squared,5), \"\\t Adjusted R-squared:  \", round(object$adj_R_squared,5), \"\\n\")\n  cat(\"'Chi2'-statistic: \", round(chi_stat,3), \" on \", p, \"DF,  p-value: \", chi_p_value)\n}\n\nplot.myglm = function(x, ...){\n  plot(x$fitted, x$y, xlab='Fitted', ylab='Observed', main='Observed vs fitted values')\n}\n\nanova.myglm = function(object, ...){\n  comp = attr(object$terms, \"term.labels\")\n  dof = Sum_Sq = numeric(length(comp)+1)\n  # Name of response\n  response = deparse(object$terms[[2]])\n  # Fit the sequence of models\n  txtFormula = paste(response, \"~\", sep = \"\")\n  model = list()\n  extra <- 0\n  for(numComp in 1:length(comp)){\n    if(numComp == 1){\n      txtFormula = paste(txtFormula, comp[numComp])\n    }\n    else{\n      txtFormula = paste(txtFormula, comp[numComp], sep = \"+\")\n    }\n    formula = formula(txtFormula)\n    model[[numComp]] = myglm(formula=formula, data = object$model)\n\n    intercept_bool <- attr(object$terms, \"intercept\")\n    num_levels <- length(levels(model[[numComp]]$model[[comp[numComp]]]))\n\n    if (num_levels == 0){\n      dof[numComp] = 1\n    } else {\n      dof[numComp] = num_levels - 1\n\n      if (extra == 0 && intercept_bool == 0){\n        extra = numComp\n      }\n\n    }\n\n    if (numComp == 1){\n      Sum_Sq[numComp] = object$rss_null - model[[numComp]]$rss_beta\n    } else {\n      Sum_Sq[numComp] = model[[numComp - 1]]$rss_beta - model[[numComp]]$rss_beta\n    }\n\n    factors_combi <- attr(model[[numComp]]$terms,\"factors\")[,numComp]\n    if(sum(factors_combi) > 1){\n      factors_combi_bool = as.logical(attr(model[[numComp]]$terms,\"factors\")[-1,numComp])\n      multi_dof <- 1\n      for (i in 1:length(factors_combi_bool)){\n        if (factors_combi_bool[i] != 0){\n          multi_dof = multi_dof * dof[i]\n        }\n      }\n      dof[numComp] = multi_dof\n    }\n  }\n\n  if (attr(object$terms, \"intercept\") == 0){\n    dof[extra] = dof[extra] + 1\n  }\n  Sum_Sq[length(Sum_Sq)] = object$rss_null - sum(Sum_Sq);           dof[length(dof)] = nrow(object$x) - ncol(object$x);\n  Mean_Sq = Sum_Sq/dof;                                             Chi2_value = Mean_Sq[1:length(Mean_Sq)-1] / Mean_Sq[length(Mean_Sq)];\n  Chi2_score = 1 - pchisq(Chi2_value,dof[length(dof) - 1])\n\n  Chi2_score[Chi2_score < 2e-16] <- '< 2e-16'\n\n  frame = data.frame(dof, Sum_Sq, Mean_Sq, c(round(Chi2_value,5), ''), c(Chi2_score,''))\n  colnames(frame) <- c('Df','Sum Sq','Mean Sq','Chi2-value','Chi2-score')\n  rownames(frame) <- c(comp, \"Residuals\")\n  cat('Analysis of Variance Table\\n')\n  cat(c('Response: ', response, '\\n'), sep='')\n  print(frame)\n  cat('--- \\n')\n  #return(model)\n}\n",
    "created" : 1474283828630.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "0|46|31|0|\n33|31|38|0|\n40|38|69|0|\n71|30|73|0|\n75|36|144|0|\n",
    "hash" : "1247736913",
    "id" : "E886B1D0",
    "lastKnownWriteTime" : 1475438017,
    "path" : "~/Documents/GIT/GLM/myglm/R/myglm.R",
    "project_path" : "R/myglm.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}