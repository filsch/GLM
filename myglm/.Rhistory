} else {
chain = c(chain, 3 + 0.8*k/(sim))
break
}
}
lines(1:n,c(chain, numeric(n - length(chain)) + chain[length(chain)]) - 0.4, col=round(runif(1)*100), type ='s', xlab='')
par(new=TRUE)
times[k] = length(chain); states[k] = chain[length(chain)]
}
abline(h = 0.5, col="red", lty="dashed", lwd=5)
abline(h = 1.5, col="blue", lty="dashed", lwd=5)
abline(h = 2.5, col="red", lty="dashed", lwd=5)
abline(h = 0.5, col=1, lty="dashed", lwd=3)
#plot alle startene i samme
n = 40; sim = 10
m = matrix(c(1,0,0,0,0.05,0.85,0.1,0,0,0.05,0.65,0.3,0,0,0,1),nrow = 4, ncol = 4, byrow=TRUE)
list_states = numeric(n)
times = numeric(sim)
states = numeric(sim)
start = 2
par(mfrow=c(1,1))
plot(1, type='n',xlim=c(1, n), ylim=c(-0.5,3.5))
for (k in 1:sim){
chain = start
for (i in 2:n){
uni <- runif(1)
if (uni <= m[chain[i-1] + 1,1]) {
chain = c(chain, 0 + 0.8*k/(sim))
break
} else if(uni <= sum(m[chain[i-1] + 1,1:2])){
chain = c(chain, 1 + 0.8*k/(sim))
} else if (uni <= sum(m[chain[i-1] + 1,1:3])) {
chain = c(chain, 2 + 0.8*k/(sim))
} else {
chain = c(chain, 3 + 0.8*k/(sim))
break
}
}
lines(1:n,c(chain, numeric(n - length(chain)) + chain[length(chain)]) - 0.4, col=round(runif(1)*100) + 1, type ='s', xlab='')
par(new=TRUE)
times[k] = length(chain); states[k] = chain[length(chain)]
}
abline(h = 0.5, col=1, lty="dashed", lwd=3)
abline(h = 1.5, col=1, lty="dashed", lwd=3)
abline(h = 2.5, col=1, lty="dashed", lwd=3)
#plot alle startene i samme
n = 40; sim = 100
m = matrix(c(1,0,0,0,0.05,0.85,0.1,0,0,0.05,0.65,0.3,0,0,0,1),nrow = 4, ncol = 4, byrow=TRUE)
list_states = numeric(n)
times = numeric(sim)
states = numeric(sim)
start = 2
par(mfrow=c(1,1))
plot(1, type='n',xlim=c(1, n), ylim=c(-0.5,3.5))
for (k in 1:sim){
chain = start + 0.8*k/sim
for (i in 2:n){
uni <- runif(1)
if (uni <= m[chain[i-1] + 1,1]) {
chain = c(chain, 0 + 0.8*k/(sim))
break
} else if(uni <= sum(m[chain[i-1] + 1,1:2])){
chain = c(chain, 1 + 0.8*k/(sim))
} else if (uni <= sum(m[chain[i-1] + 1,1:3])) {
chain = c(chain, 2 + 0.8*k/(sim))
} else {
chain = c(chain, 3 + 0.8*k/(sim))
break
}
}
lines(1:n,c(chain, numeric(n - length(chain)) + chain[length(chain)]) - 0.4, col=round(runif(1)*100) + 1, type ='s', xlab='')
par(new=TRUE)
times[k] = length(chain); states[k] = chain[length(chain)]
}
abline(h = 0.5, col=1, lty="dashed", lwd=3)
abline(h = 1.5, col=1, lty="dashed", lwd=3)
abline(h = 2.5, col=1, lty="dashed", lwd=3)
#plot alle startene i samme
n = 40; sim = 100
m = matrix(c(1,0,0,0,0.05,0.85,0.1,0,0,0.05,0.65,0.3,0,0,0,1),nrow = 4, ncol = 4, byrow=TRUE)
list_states = numeric(n)
times = numeric(sim)
states = numeric(sim)
start = 0
par(mfrow=c(1,1))
plot(1, type='n',xlim=c(1, n), ylim=c(-0.5,3.5))
for (k in 1:sim){
chain = start + 0.8*k/sim
for (i in 2:n){
uni <- runif(1)
if (uni <= m[chain[i-1] + 1,1]) {
chain = c(chain, 0 + 0.8*k/(sim))
break
} else if(uni <= sum(m[chain[i-1] + 1,1:2])){
chain = c(chain, 1 + 0.8*k/(sim))
} else if (uni <= sum(m[chain[i-1] + 1,1:3])) {
chain = c(chain, 2 + 0.8*k/(sim))
} else {
chain = c(chain, 3 + 0.8*k/(sim))
break
}
}
lines(1:n,c(chain, numeric(n - length(chain)) + chain[length(chain)]) - 0.4, col=round(runif(1)*100) + 1, type ='s', xlab='')
par(new=TRUE)
times[k] = length(chain); states[k] = chain[length(chain)]
}
abline(h = 0.5, col=1, lty="dashed", lwd=3)
abline(h = 1.5, col=1, lty="dashed", lwd=3)
abline(h = 2.5, col=1, lty="dashed", lwd=3)
#plot alle startene i samme
n = 40; sim = 100
m = matrix(c(1,0,0,0,0.05,0.85,0.1,0,0,0.05,0.65,0.3,0,0,0,1),nrow = 4, ncol = 4, byrow=TRUE)
list_states = numeric(n)
times = numeric(sim)
states = numeric(sim)
start = 1
par(mfrow=c(1,1))
plot(1, type='n',xlim=c(1, n), ylim=c(-0.5,3.5))
for (k in 1:sim){
chain = start + 0.8*k/sim
for (i in 2:n){
uni <- runif(1)
if (uni <= m[chain[i-1] + 1,1]) {
chain = c(chain, 0 + 0.8*k/(sim))
break
} else if(uni <= sum(m[chain[i-1] + 1,1:2])){
chain = c(chain, 1 + 0.8*k/(sim))
} else if (uni <= sum(m[chain[i-1] + 1,1:3])) {
chain = c(chain, 2 + 0.8*k/(sim))
} else {
chain = c(chain, 3 + 0.8*k/(sim))
break
}
}
lines(1:n,c(chain, numeric(n - length(chain)) + chain[length(chain)]) - 0.4, col=round(runif(1)*100) + 1, type ='s', xlab='')
par(new=TRUE)
times[k] = length(chain); states[k] = chain[length(chain)]
}
abline(h = 0.5, col=1, lty="dashed", lwd=3)
abline(h = 1.5, col=1, lty="dashed", lwd=3)
abline(h = 2.5, col=1, lty="dashed", lwd=3)
par(mfrow=c(2,1), mar=c(4,4,1,2) + 0.1)
plot(1:sim, cumsum(states == 0)/1:sim, type='l',
xlab='Time', ylab='Proportion', ylim=(c(0,1)),
col = 6, main = "Proportion of sim. end state")
par(new=TRUE)
plot(1:sim, cumsum(states == 3)/1:sim, type='l', xlab='',
ylab='', ylim=c(0,1), col = 4)
legend("right",c("State 0 - dead", "State 1 - functional"), fill = c(6,4), cex=0.6)
if (max(cumsum(times[states == 0])/1:sum(states == 0)) > max(cumsum(times[states == 3])/1:sum(states == 3))){
mx = max(cumsum(times[states == 0])/1:sum(states == 0)) + 1
} else {
mx = max(cumsum(times[states == 3])/1:sum(states == 3))
}
plot(1:sum(states == 0), cumsum(times[states == 0])/1:sum(states == 0), type='l',
xlab='Simulations', ylab='Mean time', ylim=c(0,mx), col = 9,
xaxt='n', main="Sim. mean time until abs. state")
par(new=TRUE)
plot(1:sum(states == 3), cumsum(times[states == 3])/1:sum(states == 3), type='l',
xlab='', ylab='',ylim=c(0,mx), col = 10, xaxt='n')
legend("bottomright",c("State 0 - dead", "State 3 - functional"), fill=c(9,10), cex=0.5)
par(mfrow=c(1,1))
plot.new()
plot(1:n, cumsum(list_states == 0)/(1:n),type='l',col = 1, ylab='Proportion of time in state',
xlab='Time', main="Air quality Markov Chain", ylim=c(0,1))
par(new=TRUE)
plot(1:n, cumsum(list_states == 1)/(1:n),type='l',col = 2, ylab='', xlab='', ylim=(c(0,1)))
par(new=TRUE)
plot(1:n, cumsum(list_states == 2)/(1:n),type='l',col = 3, ylab='', xlab='', ylim=(c(0,1)))
legend("topright",c("State 0 - very poor","State 1 - poor", "State 2 - good"),fill=c(1,2,3), cex=0.6)
#plot alle startene i samme
n = 40; sim = 100
m = matrix(c(1,0,0,0,0.05,0.85,0.1,0,0,0.05,0.65,0.3,0,0,0,1),nrow = 4, ncol = 4, byrow=TRUE)
list_states = numeric(n)
times = numeric(sim)
states = numeric(sim)
start = 1
par(mfrow=c(1,1))
plot(1, type='n',xlim=c(1, n), ylim=c(-0.5,3.5))
for (k in 1:sim){
chain = start + 0.8*k/sim
for (i in 2:n){
uni <- runif(1)
if (uni <= m[chain[i-1] + 1,1]) {
chain = c(chain, 0 + 0.8*k/(sim))
break
} else if(uni <= sum(m[chain[i-1] + 1,1:2])){
chain = c(chain, 1 + 0.8*k/(sim))
} else if (uni <= sum(m[chain[i-1] + 1,1:3])) {
chain = c(chain, 2 + 0.8*k/(sim))
} else {
chain = c(chain, 3 + 0.8*k/(sim))
break
}
}
lines(1:n,c(chain, numeric(n - length(chain)) + chain[length(chain)]) - 0.4, col=round(runif(1)*100) + 1, type ='s', xlab='')
par(new=TRUE)
times[k] = length(chain); states[k] = chain[length(chain)]
}
abline(h = 0.5, col=1, lty="dashed", lwd=3)
abline(h = 1.5, col=1, lty="dashed", lwd=3)
abline(h = 2.5, col=1, lty="dashed", lwd=3)
n = 1000
m = matrix(c(0.5,0.35,0.15,0.1,0.75,0.15,0.05,0.6,0.35), nrow=3, ncol=3, byrow=TRUE)
list_states = numeric(n)
list_states[1] = round(runif(1)*2) #Startposisjon
for (i in 2:n){
uni <- runif(1)
if (uni <= m[list_states[i-1] + 1,1]) {
list_states[i] = 0
} else if(uni <= sum(m[list_states[i-1] + 1,1:2])){
list_states[i] = 1
} else {
list_states[i] = 2
}
}
par(mfrow=c(1,1))
plot(1:n, cumsum(list_states == 0)/(1:n),type='l',col = 1, ylab='Proportion of time in state',
xlab='Time', main="Air quality Markov Chain", ylim=c(0,1))
par(new=TRUE)
plot(1:n, cumsum(list_states == 1)/(1:n),type='l',col = 2, ylab='', xlab='', ylim=(c(0,1)))
par(new=TRUE)
plot(1:n, cumsum(list_states == 2)/(1:n),type='l',col = 3, ylab='', xlab='', ylim=(c(0,1)))
legend("topright",c("State 0 - very poor","State 1 - poor", "State 2 - good"),fill=c(1,2,3), cex=0.6)
#plot alle startene i samme
n = 40; sim = 100
m = matrix(c(1,0,0,0,0.05,0.85,0.1,0,0,0.05,0.65,0.3,0,0,0,1),nrow = 4, ncol = 4, byrow=TRUE)
list_states = numeric(n)
times = numeric(sim)
states = numeric(sim)
start = 1
par(mfrow=c(1,1))
plot(1, type='n',xlim=c(1, n), ylim=c(-0.5,3.5))
for (k in 1:sim){
chain = start + 0.8*k/sim
for (i in 2:n){
uni <- runif(1)
if (uni <= m[chain[i-1] + 1,1]) {
chain = c(chain, 0 + 0.8*k/(sim))
break
} else if(uni <= sum(m[chain[i-1] + 1,1:2])){
chain = c(chain, 1 + 0.8*k/(sim))
} else if (uni <= sum(m[chain[i-1] + 1,1:3])) {
chain = c(chain, 2 + 0.8*k/(sim))
} else {
chain = c(chain, 3 + 0.8*k/(sim))
break
}
}
lines(1:n,c(chain, numeric(n - length(chain)) + chain[length(chain)]) - 0.4, col=round(runif(1)*100) + 1, type ='s', xlab='')
par(new=TRUE)
times[k] = length(chain); states[k] = chain[length(chain)]
}
abline(h = 0.5, col=1, lty="dashed", lwd=3)
abline(h = 1.5, col=1, lty="dashed", lwd=3)
abline(h = 2.5, col=1, lty="dashed", lwd=3)
par(mfrow=c(2,1), mar=c(4,4,1,2) + 0.1)
plot(1:sim, cumsum(states == 0)/1:sim, type='l',
xlab='Time', ylab='Proportion', ylim=(c(0,1)),
col = 6, main = "Proportion of sim. end state")
par(new=TRUE)
plot(1:sim, cumsum(states == 3)/1:sim, type='l', xlab='',
ylab='', ylim=c(0,1), col = 4)
legend("right",c("State 0 - dead", "State 1 - functional"), fill = c(6,4), cex=0.6)
if (max(cumsum(times[states == 0])/1:sum(states == 0)) > max(cumsum(times[states == 3])/1:sum(states == 3))){
mx = max(cumsum(times[states == 0])/1:sum(states == 0)) + 1
} else {
mx = max(cumsum(times[states == 3])/1:sum(states == 3))
}
plot(1:sum(states == 0), cumsum(times[states == 0])/1:sum(states == 0), type='l',
xlab='Simulations', ylab='Mean time', ylim=c(0,mx), col = 9,
xaxt='n', main="Sim. mean time until abs. state")
par(new=TRUE)
plot(1:sum(states == 3), cumsum(times[states == 3])/1:sum(states == 3), type='l',
xlab='', ylab='',ylim=c(0,mx), col = 10, xaxt='n')
legend("bottomright",c("State 0 - dead", "State 3 - functional"), fill=c(9,10), cex=0.5)
n = 1000
m = matrix(c(0.5,0.35,0.15,0.1,0.75,0.15,0.05,0.6,0.35), nrow=3, ncol=3, byrow=TRUE)
list_states = numeric(n)
list_states[1] = round(runif(1)*2) #Startposisjon
for (i in 2:n){
uni <- runif(1)
if (uni <= m[list_states[i-1] + 1,1]) {
list_states[i] = 0
} else if(uni <= sum(m[list_states[i-1] + 1,1:2])){
list_states[i] = 1
} else {
list_states[i] = 2
}
}
par(mfrow=c(1,1))
plot(1:n, cumsum(list_states == 0)/(1:n),type='l',col = 1, ylab='Proportion of time in state',
xlab='Time', main="Air quality Markov Chain", ylim=c(0,1))
par(new=TRUE)
plot(1:n, cumsum(list_states == 1)/(1:n),type='l',col = 2, ylab='', xlab='', ylim=(c(0,1)))
par(new=TRUE)
plot(1:n, cumsum(list_states == 2)/(1:n),type='l',col = 3, ylab='', xlab='', ylim=(c(0,1)))
legend("topright",c("State 0 - very poor","State 1 - poor", "State 2 - good"),fill=c(1,2,3), cex=0.6)
#plot alle startene i samme
n = 40; sim = 100
m = matrix(c(1,0,0,0,0.05,0.85,0.1,0,0,0.05,0.65,0.3,0,0,0,1),nrow = 4, ncol = 4, byrow=TRUE)
list_states = numeric(n)
times = numeric(sim)
states = numeric(sim)
start = 1
par(mfrow=c(1,1))
plot(1, type='n',xlim=c(1, n), ylim=c(-0.5,3.5))
for (k in 1:sim){
chain = start + 0.8*k/sim
for (i in 2:n){
uni <- runif(1)
if (uni <= m[chain[i-1] + 1,1]) {
chain = c(chain, 0 + 0.8*k/(sim))
break
} else if(uni <= sum(m[chain[i-1] + 1,1:2])){
chain = c(chain, 1 + 0.8*k/(sim))
} else if (uni <= sum(m[chain[i-1] + 1,1:3])) {
chain = c(chain, 2 + 0.8*k/(sim))
} else {
chain = c(chain, 3 + 0.8*k/(sim))
break
}
}
lines(1:n,c(chain, numeric(n - length(chain)) + chain[length(chain)]) - 0.4, col=round(runif(1)*100) + 1, type ='s', xlab='')
par(new=TRUE)
times[k] = length(chain) - 1; states[k] = chain[length(chain)]
}
abline(h = 0.5, col=1, lty="dashed", lwd=3)
abline(h = 1.5, col=1, lty="dashed", lwd=3)
abline(h = 2.5, col=1, lty="dashed", lwd=3)
par(mfrow=c(2,1), mar=c(4,4,1,2) + 0.1)
plot(1:sim, cumsum(states == 0)/1:sim, type='l',
xlab='Time', ylab='Proportion', ylim=(c(0,1)),
col = 6, main = "Proportion of sim. end state")
par(new=TRUE)
plot(1:sim, cumsum(states == 3)/1:sim, type='l', xlab='',
ylab='', ylim=c(0,1), col = 4)
legend("right",c("State 0 - dead", "State 1 - functional"), fill = c(6,4), cex=0.6)
if (max(cumsum(times[states == 0])/1:sum(states == 0)) > max(cumsum(times[states == 3])/1:sum(states == 3))){
mx = max(cumsum(times[states == 0])/1:sum(states == 0)) + 1
} else {
mx = max(cumsum(times[states == 3])/1:sum(states == 3))
}
plot(1:sum(states == 0), cumsum(times[states == 0])/1:sum(states == 0), type='l',
xlab='Simulations', ylab='Mean time', ylim=c(0,mx), col = 9,
xaxt='n', main="Sim. mean time until abs. state")
par(new=TRUE)
plot(1:sum(states == 3), cumsum(times[states == 3])/1:sum(states == 3), type='l',
xlab='', ylab='',ylim=c(0,mx), col = 10, xaxt='n')
legend("bottomright",c("State 0 - dead", "State 3 - functional"), fill=c(9,10), cex=0.5)
#plot alle startene i samme
n = 40; sim = 100
m = matrix(c(1,0,0,0,0.05,0.85,0.1,0,0,0.05,0.65,0.3,0,0,0,1),nrow = 4, ncol = 4, byrow=TRUE)
list_states = numeric(n)
times = numeric(sim)
states = numeric(sim)
start = 1
par(mfrow=c(1,1))
plot(1, type='n',xlim=c(1, n), ylim=c(-0.5,3.5))
for (k in 1:sim){
chain = start + 0.8*k/sim
for (i in 2:n){
uni <- runif(1)
if (uni <= m[chain[i-1] + 1,1]) {
chain = c(chain, 0 + 0.8*k/(sim))
break
} else if(uni <= sum(m[chain[i-1] + 1,1:2])){
chain = c(chain, 1 + 0.8*k/(sim))
} else if (uni <= sum(m[chain[i-1] + 1,1:3])) {
chain = c(chain, 2 + 0.8*k/(sim))
} else {
chain = c(chain, 3 + 0.8*k/(sim))
break
}
}
lines(1:n,c(chain, numeric(n - length(chain)) + chain[length(chain)]) - 0.4, col=round(runif(1)*100) + 1, type ='s', xlab='')
par(new=TRUE)
times[k] = length(chain) - 1; states[k] = chain[length(chain)]
}
times[k] = length(chain) - 1; states[k] = round(chain[length(chain)])
n = 1000
m = matrix(c(0.5,0.35,0.15,0.1,0.75,0.15,0.05,0.6,0.35), nrow=3, ncol=3, byrow=TRUE)
list_states = numeric(n)
list_states[1] = round(runif(1)*2) #Startposisjon
for (i in 2:n){
uni <- runif(1)
if (uni <= m[list_states[i-1] + 1,1]) {
list_states[i] = 0
} else if(uni <= sum(m[list_states[i-1] + 1,1:2])){
list_states[i] = 1
} else {
list_states[i] = 2
}
}
par(mfrow=c(1,1))
plot(1:n, cumsum(list_states == 0)/(1:n),type='l',col = 1, ylab='Proportion of time in state',
xlab='Time', main="Air quality Markov Chain", ylim=c(0,1))
par(new=TRUE)
plot(1:n, cumsum(list_states == 1)/(1:n),type='l',col = 2, ylab='', xlab='', ylim=(c(0,1)))
par(new=TRUE)
plot(1:n, cumsum(list_states == 2)/(1:n),type='l',col = 3, ylab='', xlab='', ylim=(c(0,1)))
legend("topright",c("State 0 - very poor","State 1 - poor", "State 2 - good"),fill=c(1,2,3), cex=0.6)
#plot alle startene i samme
n = 40; sim = 100
m = matrix(c(1,0,0,0,0.05,0.85,0.1,0,0,0.05,0.65,0.3,0,0,0,1),nrow = 4, ncol = 4, byrow=TRUE)
list_states = numeric(n)
times = numeric(sim)
states = numeric(sim)
start = 1
par(mfrow=c(1,1))
plot(1, type='n',xlim=c(1, n), ylim=c(-0.5,3.5))
for (k in 1:sim){
chain = start + 0.8*k/sim
for (i in 2:n){
uni <- runif(1)
if (uni <= m[chain[i-1] + 1,1]) {
chain = c(chain, 0 + 0.8*k/(sim))
break
} else if(uni <= sum(m[chain[i-1] + 1,1:2])){
chain = c(chain, 1 + 0.8*k/(sim))
} else if (uni <= sum(m[chain[i-1] + 1,1:3])) {
chain = c(chain, 2 + 0.8*k/(sim))
} else {
chain = c(chain, 3 + 0.8*k/(sim))
break
}
}
lines(1:n,c(chain, numeric(n - length(chain)) + chain[length(chain)]) - 0.4, col=round(runif(1)*100) + 1, type ='s', xlab='')
par(new=TRUE)
times[k] = length(chain) - 1; states[k] = round(chain[length(chain)])
}
abline(h = 0.5, col=1, lty="dashed", lwd=3)
abline(h = 1.5, col=1, lty="dashed", lwd=3)
abline(h = 2.5, col=1, lty="dashed", lwd=3)
n = 1000
m = matrix(c(0.5,0.35,0.15,0.1,0.75,0.15,0.05,0.6,0.35), nrow=3, ncol=3, byrow=TRUE)
list_states = numeric(n)
list_states[1] = round(runif(1)*2) #Startposisjon
for (i in 2:n){
uni <- runif(1)
if (uni <= m[list_states[i-1] + 1,1]) {
list_states[i] = 0
} else if(uni <= sum(m[list_states[i-1] + 1,1:2])){
list_states[i] = 1
} else {
list_states[i] = 2
}
}
par(mfrow=c(1,1))
plot(1:n, cumsum(list_states == 0)/(1:n),type='l',col = 1, ylab='Proportion of time in state',
xlab='Time', main="Air quality Markov Chain", ylim=c(0,1))
par(new=TRUE)
plot(1:n, cumsum(list_states == 1)/(1:n),type='l',col = 2, ylab='', xlab='', ylim=(c(0,1)))
par(new=TRUE)
plot(1:n, cumsum(list_states == 2)/(1:n),type='l',col = 3, ylab='', xlab='', ylim=(c(0,1)))
legend("topright",c("State 0 - very poor","State 1 - poor", "State 2 - good"),fill=c(1,2,3), cex=0.6)
#plot alle startene i samme
n = 40; sim = 100
m = matrix(c(1,0,0,0,0.05,0.85,0.1,0,0,0.05,0.65,0.3,0,0,0,1),nrow = 4, ncol = 4, byrow=TRUE)
list_states = numeric(n)
times = numeric(sim)
states = numeric(sim)
start = 1
par(mfrow=c(1,1))
plot(1, type='n',xlim=c(1, n), ylim=c(-0.5,3.5))
for (k in 1:sim){
chain = start + 0.8*k/sim
for (i in 2:n){
uni <- runif(1)
if (uni <= m[chain[i-1] + 1,1]) {
chain = c(chain, 0 + 0.8*k/(sim))
break
} else if(uni <= sum(m[chain[i-1] + 1,1:2])){
chain = c(chain, 1 + 0.8*k/(sim))
} else if (uni <= sum(m[chain[i-1] + 1,1:3])) {
chain = c(chain, 2 + 0.8*k/(sim))
} else {
chain = c(chain, 3 + 0.8*k/(sim))
break
}
}
lines(1:n,c(chain, numeric(n - length(chain)) + chain[length(chain)]) - 0.4, col=round(runif(1)*100) + 1, type ='s', xlab='')
par(new=TRUE)
times[k] = length(chain) - 1; states[k] = round(chain[length(chain)])
}
abline(h = 0.5, col=1, lty="dashed", lwd=3)
abline(h = 1.5, col=1, lty="dashed", lwd=3)
abline(h = 2.5, col=1, lty="dashed", lwd=3)
par(mfrow=c(2,1), mar=c(4,4,1,2) + 0.1)
plot(1:sim, cumsum(states == 0)/1:sim, type='l',
xlab='Time', ylab='Proportion', ylim=(c(0,1)),
col = 6, main = "Proportion of sim. end state")
par(new=TRUE)
plot(1:sim, cumsum(states == 3)/1:sim, type='l', xlab='',
ylab='', ylim=c(0,1), col = 4)
legend("right",c("State 0 - dead", "State 1 - functional"), fill = c(6,4), cex=0.6)
if (max(cumsum(times[states == 0])/1:sum(states == 0)) > max(cumsum(times[states == 3])/1:sum(states == 3))){
mx = max(cumsum(times[states == 0])/1:sum(states == 0)) + 1
} else {
mx = max(cumsum(times[states == 3])/1:sum(states == 3))
}
plot(1:sum(states == 0), cumsum(times[states == 0])/1:sum(states == 0), type='l',
xlab='Simulations', ylab='Mean time', ylim=c(0,mx), col = 9,
xaxt='n', main="Sim. mean time until abs. state")
par(new=TRUE)
plot(1:sum(states == 3), cumsum(times[states == 3])/1:sum(states == 3), type='l',
xlab='', ylab='',ylim=c(0,mx), col = 10, xaxt='n')
legend("bottomright",c("State 0 - dead", "State 3 - functional"), fill=c(9,10), cex=0.5)
source('~/Documents/StokPros/StokPros.R', echo=TRUE)
source('~/Documents/StokPros/StokPros.R', echo=TRUE)
source('~/Documents/StokPros/StokPros.R', echo=TRUE)
source('~/Documents/StokPros/StokPros.R', echo=TRUE)
